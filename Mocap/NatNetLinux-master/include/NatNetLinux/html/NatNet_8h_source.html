<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: NatNet.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">NatNet.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * NatNet.h is part of NatNetLinux, and is Copyright 2013-2014,</span>
<a name="l00003"></a>00003 <span class="comment"> * Philip G. Lee &lt;rocketman768@gmail.com&gt;</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * NatNetLinux is free software: you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00007"></a>00007 <span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00008"></a>00008 <span class="comment"> * (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * NatNetLinux is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment"> * along with NatNetLinux.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef NATNET_H</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define NATNET_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;ios&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
<a name="l00038"></a>00038 
<a name="l00043"></a><a class="code" href="classNatNet.html">00043</a> <span class="keyword">class </span><a class="code" href="classNatNet.html" title="Encapsulates basic NatNet communication functionality.">NatNet</a>
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045 <span class="keyword">public</span>:
<a name="l00046"></a>00046    
<a name="l00048"></a><a class="code" href="classNatNet.html#ab80fffaea8be5cb6630ee55ddb4d308b">00048</a>    <span class="keyword">static</span> <span class="keyword">const</span> uint16_t <a class="code" href="classNatNet.html#ab80fffaea8be5cb6630ee55ddb4d308b" title="Default NatNet command port.">commandPort</a>=1510;
<a name="l00050"></a><a class="code" href="classNatNet.html#ab9dfa191387ad103b5260f5a9642878d">00050</a>    <span class="keyword">static</span> <span class="keyword">const</span> uint16_t <a class="code" href="classNatNet.html#ab9dfa191387ad103b5260f5a9642878d" title="Default NatNet data port.">dataPort</a>=1511;
<a name="l00051"></a>00051    
<a name="l00063"></a><a class="code" href="classNatNet.html#a1fd6d626e9c90af62fb3c7b881fb88ee">00063</a>    <span class="keyword">static</span> <span class="keyword">struct </span>sockaddr_in <a class="code" href="classNatNet.html#a1fd6d626e9c90af62fb3c7b881fb88ee" title="Create a socket IPv4 address structure.">createAddress</a>( uint32_t inAddr, uint16_t port=<a class="code" href="classNatNet.html#ab80fffaea8be5cb6630ee55ddb4d308b" title="Default NatNet command port.">commandPort</a> )
<a name="l00064"></a>00064    {
<a name="l00065"></a>00065       <span class="keyword">struct </span>sockaddr_in ret;
<a name="l00066"></a>00066       memset(&amp;ret, 0, <span class="keyword">sizeof</span>(ret));
<a name="l00067"></a>00067       ret.sin_family = AF_INET;
<a name="l00068"></a>00068       ret.sin_port = htons(port);
<a name="l00069"></a>00069       ret.sin_addr.s_addr = inAddr;
<a name="l00070"></a>00070       
<a name="l00071"></a>00071       <span class="keywordflow">return</span> ret;
<a name="l00072"></a>00072    }
<a name="l00073"></a>00073    
<a name="l00084"></a><a class="code" href="classNatNet.html#a98dd9ad26ce6baf0444f51f51812626a">00084</a>    <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classNatNet.html#a98dd9ad26ce6baf0444f51f51812626a" title="Creates a socket for receiving commands.">createCommandSocket</a>( uint32_t inAddr, uint16_t port=<a class="code" href="classNatNet.html#ab80fffaea8be5cb6630ee55ddb4d308b" title="Default NatNet command port.">commandPort</a> )
<a name="l00085"></a>00085    {
<a name="l00086"></a>00086       <span class="comment">// Asking for a buffer of 1MB = 2^20 bytes. This is what NP does, but this</span>
<a name="l00087"></a>00087       <span class="comment">// seems far too large on Linux systems where the max is usually something</span>
<a name="l00088"></a>00088       <span class="comment">// like 256 kB.</span>
<a name="l00089"></a>00089       <span class="keyword">const</span> <span class="keywordtype">int</span> rcvBufSize = 0x1E800;
<a name="l00090"></a>00090       <span class="keywordtype">int</span> sd;
<a name="l00091"></a>00091       <span class="keywordtype">int</span> tmp=0;
<a name="l00092"></a>00092       socklen_t len= (socklen_t) <span class="keyword">sizeof</span>(tmp); <span class="comment">//0;</span>
<a name="l00093"></a>00093       <span class="keyword">struct </span>sockaddr_in sockAddr = <a class="code" href="classNatNet.html#a1fd6d626e9c90af62fb3c7b881fb88ee" title="Create a socket IPv4 address structure.">createAddress</a>(inAddr, port);
<a name="l00094"></a>00094       
<a name="l00095"></a>00095       sd = socket(AF_INET, SOCK_DGRAM, 0);
<a name="l00096"></a>00096       <span class="keywordflow">if</span>( sd &lt; 0 )
<a name="l00097"></a>00097       {
<a name="l00098"></a>00098          std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not open socket. Error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;
<a name="l00099"></a>00099          exit(1);
<a name="l00100"></a>00100       }
<a name="l00101"></a>00101       
<a name="l00102"></a>00102       <span class="comment">// Bind socket to the address.</span>
<a name="l00103"></a>00103       tmp = bind( sd, (<span class="keyword">struct</span> sockaddr*)&amp;sockAddr, <span class="keyword">sizeof</span>(sockAddr) );
<a name="l00104"></a>00104       <span class="keywordflow">if</span>( tmp &lt; 0 )
<a name="l00105"></a>00105       {
<a name="l00106"></a>00106          std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not bind socket. Error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;
<a name="l00107"></a>00107          close(sd);
<a name="l00108"></a>00108          exit(1);
<a name="l00109"></a>00109       }
<a name="l00110"></a>00110       
<a name="l00111"></a>00111       <span class="keywordtype">int</span> value = 1;
<a name="l00112"></a>00112       tmp = setsockopt( sd, SOL_SOCKET, SO_BROADCAST, (<span class="keywordtype">char</span>*)&amp;value, <span class="keyword">sizeof</span>(value) );
<a name="l00113"></a>00113       <span class="keywordflow">if</span>( tmp &lt; 0 )
<a name="l00114"></a>00114       {
<a name="l00115"></a>00115          std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not set socket to broadcast mode. Error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;
<a name="l00116"></a>00116          close(sd);
<a name="l00117"></a>00117          exit(1);
<a name="l00118"></a>00118       }
<a name="l00119"></a>00119       
<a name="l00120"></a>00120       setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (<span class="keywordtype">char</span>*)&amp;rcvBufSize, <span class="keyword">sizeof</span>(rcvBufSize));
<a name="l00121"></a>00121       getsockopt(sd, SOL_SOCKET, SO_RCVBUF, (<span class="keywordtype">char</span>*)&amp;tmp, &amp;len );
<a name="l00122"></a>00122       <span class="keywordflow">if</span>( tmp &lt; rcvBufSize )
<a name="l00123"></a>00123       {
<a name="l00124"></a>00124          std::cerr &lt;&lt; <span class="stringliteral">&quot;WARNING: Could not set receive buffer size. Asked for &quot;</span>
<a name="l00125"></a>00125             &lt;&lt; rcvBufSize &lt;&lt; <span class="stringliteral">&quot;B got &quot;</span> &lt;&lt; tmp &lt;&lt; <span class="stringliteral">&quot;B&quot;</span> &lt;&lt; std::endl;
<a name="l00126"></a>00126       }
<a name="l00127"></a>00127       
<a name="l00128"></a>00128       <span class="keywordflow">return</span> sd;
<a name="l00129"></a>00129    }
<a name="l00130"></a>00130    
<a name="l00143"></a><a class="code" href="classNatNet.html#a33b6d6f52a107f1c0a6aaa2023b3be60">00143</a>    <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classNatNet.html#a33b6d6f52a107f1c0a6aaa2023b3be60" title="Creates a socket to read data from the server.">createDataSocket</a>( uint32_t inAddr, uint16_t port=<a class="code" href="classNatNet.html#ab9dfa191387ad103b5260f5a9642878d" title="Default NatNet data port.">dataPort</a>, uint32_t multicastAddr=inet_addr(<span class="stringliteral">&quot;239.255.42.99&quot;</span>) )
<a name="l00144"></a>00144    {
<a name="l00145"></a>00145       <span class="keywordtype">int</span> sd;
<a name="l00146"></a>00146       <span class="keywordtype">int</span> value;
<a name="l00147"></a>00147       <span class="keywordtype">int</span> tmp;
<a name="l00148"></a>00148       <span class="keyword">struct </span>ip_mreq group;
<a name="l00149"></a>00149       <span class="keyword">struct </span>sockaddr_in localSock = <span class="comment">/*createAddress(inAddr,port); */</span>    <a class="code" href="classNatNet.html#a1fd6d626e9c90af62fb3c7b881fb88ee" title="Create a socket IPv4 address structure.">createAddress</a>(INADDR_ANY, port);
<a name="l00150"></a>00150       
<a name="l00151"></a>00151       <span class="keywordflow">if</span>((sd = socket(AF_INET, SOCK_DGRAM, 0))  == -1)
<a name="l00152"></a>00152       {
<a name="l00153"></a>00153          printf(<span class="stringliteral">&quot;The data socket coul not be created&quot;</span>);
<a name="l00154"></a>00154          close(sd);
<a name="l00155"></a>00155          <span class="keywordflow">return</span> -1;
<a name="l00156"></a>00156       }
<a name="l00157"></a>00157       value = 1;
<a name="l00158"></a>00158       tmp = setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (<span class="keywordtype">char</span>*)&amp;value, <span class="keyword">sizeof</span>(value));
<a name="l00159"></a>00159       <span class="keywordflow">if</span>( tmp &lt; 0 )
<a name="l00160"></a>00160       {
<a name="l00161"></a>00161          std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: Could not set socket option.&quot;</span> &lt;&lt; std::endl;
<a name="l00162"></a>00162          close(sd);
<a name="l00163"></a>00163          <span class="keywordflow">return</span> -1;
<a name="l00164"></a>00164       }
<a name="l00165"></a>00165       
<a name="l00166"></a>00166       <span class="comment">// Bind the socket to a port.</span>
<a name="l00167"></a>00167       <span class="keywordflow">if</span>( (bind(sd, (<span class="keyword">struct</span> sockaddr*)&amp;localSock, <span class="keyword">sizeof</span>(localSock))) == -1 )
<a name="l00168"></a>00168       {
<a name="l00169"></a>00169          printf(<span class="stringliteral">&quot;Failed to bind the data socket\n&quot;</span>);
<a name="l00170"></a>00170          close(sd);
<a name="l00171"></a>00171          <span class="keywordflow">return</span> -1;
<a name="l00172"></a>00172       }
<a name="l00173"></a>00173       
<a name="l00174"></a>00174       <span class="comment">// Connect a local interface address to the multicast interface address.</span>
<a name="l00175"></a>00175       group.imr_multiaddr.s_addr = multicastAddr;
<a name="l00176"></a>00176       group.imr_interface.s_addr = inAddr;
<a name="l00177"></a>00177       tmp = setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="keywordtype">char</span>*)&amp;group, <span class="keyword">sizeof</span>(group));
<a name="l00178"></a>00178       <span class="keywordflow">if</span>( tmp &lt; 0 )
<a name="l00179"></a>00179       {
<a name="l00180"></a>00180          std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: Could not add the interface to the multicast group.&quot;</span> &lt;&lt; std::endl;
<a name="l00181"></a>00181          close(sd);
<a name="l00182"></a>00182          <span class="keywordflow">return</span> -1;
<a name="l00183"></a>00183       }
<a name="l00184"></a>00184       
<a name="l00185"></a>00185       <span class="keywordflow">return</span> sd;
<a name="l00186"></a>00186    }
<a name="l00187"></a>00187 };
<a name="l00188"></a>00188 
<a name="l00193"></a><a class="code" href="classPoint3f.html">00193</a> <span class="keyword">class </span><a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195 <span class="keyword">public</span>:
<a name="l00196"></a>00196    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>( <span class="keywordtype">float</span> xx=0.f, <span class="keywordtype">float</span> yy=0.f, <span class="keywordtype">float</span> zz=0.f ) :
<a name="l00197"></a>00197       x(xx), y(yy), z(zz)
<a name="l00198"></a>00198    {
<a name="l00199"></a>00199    }
<a name="l00200"></a>00200    
<a name="l00201"></a>00201    ~<a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>() {}
<a name="l00202"></a>00202    
<a name="l00203"></a>00203    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>( <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00204"></a>00204       x(other.x),
<a name="l00205"></a>00205       y(other.y),
<a name="l00206"></a>00206       z(other.z)
<a name="l00207"></a>00207    {
<a name="l00208"></a>00208    }
<a name="l00209"></a>00209    
<a name="l00210"></a>00210    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>&amp; operator=( <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <span class="keyword">const</span>&amp; other )
<a name="l00211"></a>00211    {
<a name="l00212"></a>00212       <span class="comment">// Self-assignment no problem</span>
<a name="l00213"></a>00213       x = other.x;
<a name="l00214"></a>00214       y = other.y;
<a name="l00215"></a>00215       z = other.z;
<a name="l00216"></a>00216       
<a name="l00217"></a>00217       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00218"></a>00218    }
<a name="l00219"></a>00219    
<a name="l00220"></a>00220    <span class="keywordtype">float</span> x;
<a name="l00221"></a>00221    <span class="keywordtype">float</span> y;
<a name="l00222"></a>00222    <span class="keywordtype">float</span> z;
<a name="l00223"></a>00223 };
<a name="l00224"></a>00224 
<a name="l00226"></a>00226 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; s, <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <span class="keyword">const</span>&amp; point )
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228    std::ios::fmtflags f(s.flags());
<a name="l00229"></a>00229    
<a name="l00230"></a>00230    s
<a name="l00231"></a>00231    &lt;&lt; std::fixed
<a name="l00232"></a>00232    &lt;&lt; <span class="stringliteral">&quot;( &quot;</span>
<a name="l00233"></a>00233    &lt;&lt; std::setprecision(3) &lt;&lt; point.x &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00234"></a>00234    &lt;&lt; std::setprecision(3) &lt;&lt; point.y &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00235"></a>00235    &lt;&lt; std::setprecision(3) &lt;&lt; point.z &lt;&lt; <span class="stringliteral">&quot; )&quot;</span> &lt;&lt; std::endl;
<a name="l00236"></a>00236    
<a name="l00237"></a>00237    s.flags(f);
<a name="l00238"></a>00238    
<a name="l00239"></a>00239    <span class="keywordflow">return</span> s;
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 
<a name="l00253"></a><a class="code" href="classQuaternion4f.html">00253</a> <span class="keyword">class </span><a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a>
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255 <span class="keyword">public</span>:
<a name="l00256"></a>00256    <span class="keywordtype">float</span> qx;
<a name="l00257"></a>00257    <span class="keywordtype">float</span> qy;
<a name="l00258"></a>00258    <span class="keywordtype">float</span> qz;
<a name="l00259"></a>00259    <span class="keywordtype">float</span> qw;
<a name="l00260"></a>00260    
<a name="l00262"></a><a class="code" href="classQuaternion4f.html#aa0b0ab1907488bb4fbdf97ebca59c025">00262</a>    <a class="code" href="classQuaternion4f.html#aa0b0ab1907488bb4fbdf97ebca59c025" title="Default constructor. Without parameters, returns the identity (no rotation).">Quaternion4f</a>( <span class="keywordtype">float</span> qx=0.f, <span class="keywordtype">float</span> qy=0.f, <span class="keywordtype">float</span> qz=0.f, <span class="keywordtype">float</span> qw=1.f ) :
<a name="l00263"></a>00263       qx(qx),
<a name="l00264"></a>00264       qy(qy),
<a name="l00265"></a>00265       qz(qz),
<a name="l00266"></a>00266       qw(qw)
<a name="l00267"></a>00267    {
<a name="l00268"></a>00268       renormalize();
<a name="l00269"></a>00269    }
<a name="l00270"></a>00270    
<a name="l00271"></a>00271    ~<a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a>(){}
<a name="l00272"></a>00272    
<a name="l00274"></a><a class="code" href="classQuaternion4f.html#a1262b3e2dbb4bd3b83940e08f668d2ba">00274</a>    <a class="code" href="classQuaternion4f.html#aa0b0ab1907488bb4fbdf97ebca59c025" title="Default constructor. Without parameters, returns the identity (no rotation).">Quaternion4f</a>( <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00275"></a>00275       qx(other.qx),
<a name="l00276"></a>00276       qy(other.qy),
<a name="l00277"></a>00277       qz(other.qz),
<a name="l00278"></a>00278       qw(other.qw)
<a name="l00279"></a>00279    {
<a name="l00280"></a>00280    }
<a name="l00281"></a>00281    
<a name="l00283"></a><a class="code" href="classQuaternion4f.html#a9d549795b575fbeda96bd4308224f875">00283</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a>&amp; <a class="code" href="classQuaternion4f.html#a9d549795b575fbeda96bd4308224f875" title="Assignment operator.">operator=</a>( <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; other )
<a name="l00284"></a>00284    {
<a name="l00285"></a>00285       qx = other.qx;
<a name="l00286"></a>00286       qy = other.qy;
<a name="l00287"></a>00287       qz = other.qz;
<a name="l00288"></a>00288       qw = other.qw;
<a name="l00289"></a>00289       
<a name="l00290"></a>00290       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00291"></a>00291    }
<a name="l00292"></a>00292    
<a name="l00294"></a><a class="code" href="classQuaternion4f.html#ad93f8e2f8843aa96d5418b5d4c0122cb">00294</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a>&amp; <a class="code" href="classQuaternion4f.html#ad93f8e2f8843aa96d5418b5d4c0122cb" title="Quaternion multiplication/assignment.">operator*=</a>(<a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; rhs)
<a name="l00295"></a>00295    {
<a name="l00296"></a>00296       <span class="keywordtype">float</span> x,y,z,w;
<a name="l00297"></a>00297       
<a name="l00298"></a>00298       x = qw*rhs.qw - qx*rhs.qx - qy*rhs.qy - qz*rhs.qz;
<a name="l00299"></a>00299       y = qw*rhs.qx + qx*rhs.qw + qy*rhs.qz - qz*rhs.qy;
<a name="l00300"></a>00300       z = qw*rhs.qy - qx*rhs.qz + qy*rhs.qw + qz*rhs.qx;
<a name="l00301"></a>00301       w = qw*rhs.qz + qx*rhs.qy - qy*rhs.qx + qz*rhs.qw;
<a name="l00302"></a>00302       
<a name="l00303"></a>00303       qx = x;
<a name="l00304"></a>00304       qy = y;
<a name="l00305"></a>00305       qz = z;
<a name="l00306"></a>00306       qw = w;
<a name="l00307"></a>00307       
<a name="l00308"></a>00308       renormalize();
<a name="l00309"></a>00309       
<a name="l00310"></a>00310       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00311"></a>00311    }
<a name="l00312"></a>00312    
<a name="l00314"></a><a class="code" href="classQuaternion4f.html#a1d9d76b4fdeb48bc07facc4c9f4e0077">00314</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <a class="code" href="classQuaternion4f.html#a1d9d76b4fdeb48bc07facc4c9f4e0077" title="Quaternion multiplication (rotation composition)">operator*</a>(<a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00315"></a>00315 <span class="keyword">   </span>{
<a name="l00316"></a>00316       <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> ret(*<span class="keyword">this</span>);
<a name="l00317"></a>00317       
<a name="l00318"></a>00318       ret *= rhs;
<a name="l00319"></a>00319       
<a name="l00320"></a>00320       <span class="keywordflow">return</span> ret;
<a name="l00321"></a>00321    }
<a name="l00322"></a>00322    
<a name="l00324"></a><a class="code" href="classQuaternion4f.html#ac14442267435abd2e8daf0fc81b5e435">00324</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a>&amp; <a class="code" href="classQuaternion4f.html#ac14442267435abd2e8daf0fc81b5e435" title="Quaternion division/assignment.">operator/=</a>(<a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; rhs)
<a name="l00325"></a>00325    {
<a name="l00326"></a>00326       <span class="comment">// Create the conjugate and multiply.</span>
<a name="l00327"></a>00327       <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> rhsConj(-rhs.qx, -rhs.qy, -rhs.qy, rhs.qw);
<a name="l00328"></a>00328       *<span class="keyword">this</span> *= rhsConj;
<a name="l00329"></a>00329       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00330"></a>00330    }
<a name="l00331"></a>00331    
<a name="l00333"></a><a class="code" href="classQuaternion4f.html#a608114a34406bfc9d451bf365edf81a8">00333</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <a class="code" href="classQuaternion4f.html#a608114a34406bfc9d451bf365edf81a8" title="Quaternion division.">operator/</a>(<a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; rhs)<span class="keyword"> const</span>
<a name="l00334"></a>00334 <span class="keyword">   </span>{
<a name="l00335"></a>00335       <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> ret(*<span class="keyword">this</span>);
<a name="l00336"></a>00336       ret /= rhs;
<a name="l00337"></a>00337       <span class="keywordflow">return</span> ret;
<a name="l00338"></a>00338    }
<a name="l00339"></a>00339    
<a name="l00341"></a><a class="code" href="classQuaternion4f.html#aeabc49bffd763065dc0e77ae26c9f6c6">00341</a>    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <a class="code" href="classQuaternion4f.html#aeabc49bffd763065dc0e77ae26c9f6c6" title="Rotate a point using the quaternion.">rotate</a>(<a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <span class="keyword">const</span>&amp; p)<span class="keyword"> const</span>
<a name="l00342"></a>00342 <span class="keyword">   </span>{
<a name="l00343"></a>00343       <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> pout;
<a name="l00344"></a>00344       
<a name="l00345"></a>00345       pout.x = (1.f-2.f*qy*qy-2.f*qz*qz)*p.x + (2.f*qx*qy-2.f*qw*qz)*p.y + (2.f*qx*qz+2.f*qw*qy)*p.z;
<a name="l00346"></a>00346       pout.y = (2.f*qx*qy+2.f*qw*qz)*p.x + (1.f-2.f*qx*qx-2.f*qz*qz)*p.y + (2.f*qy*qz+2.f*qw*qx)*p.z;
<a name="l00347"></a>00347       pout.z = (2.f*qx*qz-2.f*qw*qy)*p.x + (2.f*qy*qz-2.f*qw*qx)*p.y + (1.f-2.f*qx*qx-2.f*qy*qy)*p.z;
<a name="l00348"></a>00348       
<a name="l00349"></a>00349       <span class="keywordflow">return</span> pout;
<a name="l00350"></a>00350    }
<a name="l00351"></a>00351    
<a name="l00352"></a>00352 <span class="keyword">private</span>:
<a name="l00353"></a>00353    
<a name="l00354"></a>00354    <span class="comment">// If the magnitude of the quaternion exceeds a tolerance, renormalize it</span>
<a name="l00355"></a>00355    <span class="comment">// to have magnitude of 1.</span>
<a name="l00356"></a>00356    <span class="keywordtype">void</span> renormalize()
<a name="l00357"></a>00357    {
<a name="l00358"></a>00358       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> tolHigh = 1.f+1e-6;
<a name="l00359"></a>00359       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> tolLow  = 1.f-1e-6;
<a name="l00360"></a>00360       
<a name="l00361"></a>00361       <span class="keywordtype">float</span> mag = qx*qx + qy*qy + qw*qw + qz*qz;
<a name="l00362"></a>00362       
<a name="l00363"></a>00363       <span class="keywordflow">if</span>( mag &lt; tolLow || mag &gt; tolHigh )
<a name="l00364"></a>00364       {
<a name="l00365"></a>00365          mag = sqrtf( mag );
<a name="l00366"></a>00366          qx /= mag;
<a name="l00367"></a>00367          qy /= mag;
<a name="l00368"></a>00368          qz /= mag;
<a name="l00369"></a>00369          qw /= mag;
<a name="l00370"></a>00370       }
<a name="l00371"></a>00371    }
<a name="l00372"></a>00372 };
<a name="l00373"></a>00373 
<a name="l00375"></a>00375 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; s, <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <span class="keyword">const</span>&amp; q )
<a name="l00376"></a>00376 {
<a name="l00377"></a>00377    std::ios::fmtflags f(s.flags());
<a name="l00378"></a>00378    
<a name="l00379"></a>00379    s
<a name="l00380"></a>00380    &lt;&lt; std::fixed
<a name="l00381"></a>00381    &lt;&lt; <span class="stringliteral">&quot;(qx,qy,qz,qw) = ( &quot;</span>
<a name="l00382"></a>00382    &lt;&lt; std::setprecision(3) &lt;&lt; q.qx &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00383"></a>00383    &lt;&lt; std::setprecision(3) &lt;&lt; q.qy &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00384"></a>00384    &lt;&lt; std::setprecision(3) &lt;&lt; q.qz &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00385"></a>00385    &lt;&lt; std::setprecision(3) &lt;&lt; q.qw &lt;&lt; <span class="stringliteral">&quot; )&quot;</span> &lt;&lt; std::endl;
<a name="l00386"></a>00386    
<a name="l00387"></a>00387    s.flags(f);
<a name="l00388"></a>00388    
<a name="l00389"></a>00389    <span class="keywordflow">return</span> s;
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00400"></a><a class="code" href="classRigidBody.html">00400</a> <span class="keyword">class </span><a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a>
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402 <span class="keyword">public</span>:
<a name="l00403"></a>00403    
<a name="l00405"></a><a class="code" href="classRigidBody.html#a28203d38d278da0695ace20c66ee5f0a">00405</a>    <a class="code" href="classRigidBody.html#a28203d38d278da0695ace20c66ee5f0a" title="Default constructor.">RigidBody</a>() :
<a name="l00406"></a>00406       _id(-1),
<a name="l00407"></a>00407       _loc(),
<a name="l00408"></a>00408       _ori(),
<a name="l00409"></a>00409       _markers(),
<a name="l00410"></a>00410       _mId(),
<a name="l00411"></a>00411       _mSize(),
<a name="l00412"></a>00412       _mErr(),
<a name="l00413"></a>00413       _trackingValid(true)
<a name="l00414"></a>00414    {
<a name="l00415"></a>00415    }
<a name="l00416"></a>00416    
<a name="l00418"></a><a class="code" href="classRigidBody.html#a21f6709d0695b1bbbc53b3c4ecc65805">00418</a>    <a class="code" href="classRigidBody.html#a28203d38d278da0695ace20c66ee5f0a" title="Default constructor.">RigidBody</a>( <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00419"></a>00419       _id(other._id),
<a name="l00420"></a>00420       _loc(other._loc),
<a name="l00421"></a>00421       _ori(other._ori),
<a name="l00422"></a>00422       _markers(other._markers),
<a name="l00423"></a>00423       _mId(other._mId),
<a name="l00424"></a>00424       _mSize(other._mSize),
<a name="l00425"></a>00425       _mErr(other._mErr),
<a name="l00426"></a>00426       _trackingValid(other._trackingValid)
<a name="l00427"></a>00427    {
<a name="l00428"></a>00428    }
<a name="l00429"></a>00429    
<a name="l00430"></a>00430    ~<a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a>(){}
<a name="l00431"></a>00431    
<a name="l00433"></a><a class="code" href="classRigidBody.html#afa52b4614ec2a06d4c296e2decb15863">00433</a>    <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a>&amp; <a class="code" href="classRigidBody.html#afa52b4614ec2a06d4c296e2decb15863" title="Assignment operator.">operator=</a>( <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a> <span class="keyword">const</span>&amp; other )
<a name="l00434"></a>00434    {
<a name="l00435"></a>00435       _id = other._id;
<a name="l00436"></a>00436       _loc = other._loc;
<a name="l00437"></a>00437       _ori = other._ori;
<a name="l00438"></a>00438       _markers = other._markers;
<a name="l00439"></a>00439       _mId = other._mId;
<a name="l00440"></a>00440       _mSize = other._mSize;
<a name="l00441"></a>00441       _mErr = other._mErr;
<a name="l00442"></a>00442       _trackingValid = other._trackingValid;
<a name="l00443"></a>00443       
<a name="l00444"></a>00444       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00445"></a>00445    }
<a name="l00446"></a>00446    
<a name="l00448"></a><a class="code" href="classRigidBody.html#a14a65e35826b8298f7248d02e09a1e91">00448</a>    <span class="keywordtype">int</span> <a class="code" href="classRigidBody.html#a14a65e35826b8298f7248d02e09a1e91" title="ID of this RigidBody.">id</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _id; }
<a name="l00450"></a><a class="code" href="classRigidBody.html#a5dd602d6ad2263f72ac284394b19983c">00450</a>    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <a class="code" href="classRigidBody.html#a5dd602d6ad2263f72ac284394b19983c" title="Location of this RigidBody.">location</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _loc; }
<a name="l00452"></a><a class="code" href="classRigidBody.html#a63dd7b3d272ebb6a231de1c7fba9d1b1">00452</a>    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> <a class="code" href="classRigidBody.html#a63dd7b3d272ebb6a231de1c7fba9d1b1" title="Orientation of this RigidBody.">orientation</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _ori; }
<a name="l00454"></a><a class="code" href="classRigidBody.html#ad9a2b2fd5b8bcda1209c52534e1c731e">00454</a>    std::vector&lt;Point3f&gt; <span class="keyword">const</span>&amp; <a class="code" href="classRigidBody.html#ad9a2b2fd5b8bcda1209c52534e1c731e" title="Vector of markers that make up this RigidBody.">markers</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _markers; }
<a name="l00456"></a><a class="code" href="classRigidBody.html#aadc9990e94a810c9f425aca4f1e8c989">00456</a>    <span class="keywordtype">bool</span> <a class="code" href="classRigidBody.html#aadc9990e94a810c9f425aca4f1e8c989" title="True if the tracking is valid. Used in NatNet version &gt;= 2.6.">trackingValid</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _trackingValid; }
<a name="l00457"></a>00457    
<a name="l00466"></a><a class="code" href="classRigidBody.html#ac2670bcfaee0e6224a3a21c32668f415">00466</a>    <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classRigidBody.html#ac2670bcfaee0e6224a3a21c32668f415" title="Unpack rigid body data from raw packed data.">unpack</a>(<span class="keywordtype">char</span> <span class="keyword">const</span>* data, <span class="keywordtype">char</span> nnMajor, <span class="keywordtype">char</span> nnMinor)
<a name="l00467"></a>00467    {
<a name="l00468"></a>00468       <span class="keywordtype">int</span> i;
<a name="l00469"></a>00469       <span class="keywordtype">float</span> x,y,z;
<a name="l00470"></a>00470       
<a name="l00471"></a>00471       <span class="comment">// Rigid body ID</span>
<a name="l00472"></a>00472       memcpy(&amp;_id,data,4); data += 4;
<a name="l00473"></a>00473       
<a name="l00474"></a>00474       <span class="comment">// Location and orientation.</span>
<a name="l00475"></a>00475       memcpy(&amp;_loc.x,data,4); data += 4;
<a name="l00476"></a>00476       memcpy(&amp;_loc.y,data,4); data += 4;
<a name="l00477"></a>00477       memcpy(&amp;_loc.z,data,4); data += 4;
<a name="l00478"></a>00478       memcpy(&amp;_ori.qx,data,4); data += 4;
<a name="l00479"></a>00479       memcpy(&amp;_ori.qy,data,4); data += 4;
<a name="l00480"></a>00480       memcpy(&amp;_ori.qz,data,4); data += 4;
<a name="l00481"></a>00481       memcpy(&amp;_ori.qw,data,4); data += 4;
<a name="l00482"></a>00482       
<a name="l00483"></a>00483       <span class="comment">// Associated markers</span>
<a name="l00484"></a>00484       <span class="keywordtype">int</span> nMarkers = 0;
<a name="l00485"></a>00485       memcpy(&amp;nMarkers,data,4); data += 4;
<a name="l00486"></a>00486       <span class="keywordflow">for</span>( i = 0; i &lt; nMarkers; ++i )
<a name="l00487"></a>00487       {
<a name="l00488"></a>00488          memcpy(&amp;x,data,4); data += 4;
<a name="l00489"></a>00489          memcpy(&amp;y,data,4); data += 4;
<a name="l00490"></a>00490          memcpy(&amp;z,data,4); data += 4;
<a name="l00491"></a>00491          _markers.push_back(<a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>(x,y,z));
<a name="l00492"></a>00492       }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494       <span class="keywordflow">if</span>( nnMajor &gt;= 2 )
<a name="l00495"></a>00495       {
<a name="l00496"></a>00496          <span class="comment">// Marker IDs</span>
<a name="l00497"></a>00497          uint32_t <span class="keywordtype">id</span> = 0;
<a name="l00498"></a>00498          <span class="keywordflow">for</span>( i = 0; i &lt; nMarkers; ++i )
<a name="l00499"></a>00499          {
<a name="l00500"></a>00500             memcpy(&amp;<span class="keywordtype">id</span>,data,4); data += 4;
<a name="l00501"></a>00501             _mId.push_back(<span class="keywordtype">id</span>);
<a name="l00502"></a>00502          }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504          <span class="comment">// Marker sizes</span>
<a name="l00505"></a>00505          <span class="keywordtype">float</span> size;
<a name="l00506"></a>00506          <span class="keywordflow">for</span>( i = 0; i &lt; nMarkers; ++i )
<a name="l00507"></a>00507          {
<a name="l00508"></a>00508             memcpy(&amp;size,data,4); data += 4;
<a name="l00509"></a>00509             _mSize.push_back(size);
<a name="l00510"></a>00510          }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512          <span class="keywordflow">if</span>( ((nnMajor==2) &amp;&amp; (nnMinor &gt;= 6)) || (nnMajor &gt; 2) || (nnMajor == 0) )
<a name="l00513"></a>00513          {
<a name="l00514"></a>00514             uint16_t tmp;
<a name="l00515"></a>00515             memcpy(&amp;tmp, data, 2); data += 2;
<a name="l00516"></a>00516             _trackingValid = tmp &amp; 0x01;
<a name="l00517"></a>00517          }
<a name="l00518"></a>00518          <span class="comment">// Mean marker error</span>
<a name="l00519"></a>00519          memcpy(&amp;_mErr,data,4); data += 4;
<a name="l00520"></a>00520       }
<a name="l00521"></a>00521       
<a name="l00522"></a>00522       <span class="keywordflow">return</span> data;
<a name="l00523"></a>00523    }
<a name="l00524"></a>00524    
<a name="l00525"></a>00525 <span class="keyword">private</span>:
<a name="l00526"></a>00526    <span class="keywordtype">int</span> _id;
<a name="l00527"></a>00527    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> _loc;
<a name="l00528"></a>00528    <a class="code" href="classQuaternion4f.html" title="Quaternion for 3D rotations and orientation.">Quaternion4f</a> _ori;
<a name="l00529"></a>00529    <span class="comment">// List of [x,y,z] positions of each marker.</span>
<a name="l00530"></a>00530    std::vector&lt;Point3f&gt; _markers;
<a name="l00531"></a>00531    
<a name="l00532"></a>00532    <span class="comment">// NOTE: If NatNet.major &gt;= 2</span>
<a name="l00533"></a>00533    <span class="comment">// List of marker IDs (each uint32_t)</span>
<a name="l00534"></a>00534    std::vector&lt;uint32_t&gt; _mId;
<a name="l00535"></a>00535    <span class="comment">// List of marker sizes (each float)</span>
<a name="l00536"></a>00536    std::vector&lt;float&gt; _mSize;
<a name="l00537"></a>00537    <span class="comment">// Mean marker error</span>
<a name="l00538"></a>00538    <span class="keywordtype">float</span> _mErr;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540    <span class="comment">// NOTE: If NatNet version &gt;= 2.6</span>
<a name="l00541"></a>00541    <span class="keywordtype">bool</span> _trackingValid;
<a name="l00542"></a>00542 };
<a name="l00543"></a>00543 
<a name="l00545"></a>00545 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; s, <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a> <span class="keyword">const</span>&amp; body )
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547    s
<a name="l00548"></a>00548    &lt;&lt; <span class="stringliteral">&quot;    Rigid Body: &quot;</span> &lt;&lt; body.<a class="code" href="classRigidBody.html#a14a65e35826b8298f7248d02e09a1e91" title="ID of this RigidBody.">id</a>() &lt;&lt; std::endl
<a name="l00549"></a>00549    &lt;&lt; <span class="stringliteral">&quot;      loc: &quot;</span> &lt;&lt; body.<a class="code" href="classRigidBody.html#a5dd602d6ad2263f72ac284394b19983c" title="Location of this RigidBody.">location</a>()
<a name="l00550"></a>00550    &lt;&lt; <span class="stringliteral">&quot;      ori: &quot;</span> &lt;&lt; body.<a class="code" href="classRigidBody.html#a63dd7b3d272ebb6a231de1c7fba9d1b1" title="Orientation of this RigidBody.">orientation</a>() &lt;&lt; std::endl;
<a name="l00551"></a>00551    
<a name="l00552"></a>00552    <span class="keywordflow">return</span> s;
<a name="l00553"></a>00553 }
<a name="l00554"></a>00554 
<a name="l00559"></a><a class="code" href="classMarkerSet.html">00559</a> <span class="keyword">class </span><a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a>
<a name="l00560"></a>00560 {
<a name="l00561"></a>00561 <span class="keyword">public</span>:
<a name="l00563"></a><a class="code" href="classMarkerSet.html#af44729e54615850f8491f4a951131201">00563</a>    <a class="code" href="classMarkerSet.html#af44729e54615850f8491f4a951131201" title="Default constructor.">MarkerSet</a>() :
<a name="l00564"></a>00564       _name(),
<a name="l00565"></a>00565       _markers()
<a name="l00566"></a>00566    {
<a name="l00567"></a>00567    }
<a name="l00568"></a>00568    
<a name="l00569"></a>00569    ~<a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a>(){}
<a name="l00570"></a>00570    
<a name="l00572"></a><a class="code" href="classMarkerSet.html#aaa2d94ce271768803afcd5558963f603">00572</a>    <a class="code" href="classMarkerSet.html#af44729e54615850f8491f4a951131201" title="Default constructor.">MarkerSet</a>( <a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00573"></a>00573       _name(other._name),
<a name="l00574"></a>00574       _markers(other._markers)
<a name="l00575"></a>00575    {
<a name="l00576"></a>00576    }
<a name="l00577"></a>00577    
<a name="l00579"></a><a class="code" href="classMarkerSet.html#ad8bf3331c2dd4a3dcf0193f49c5a123a">00579</a>    <a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a>&amp; <a class="code" href="classMarkerSet.html#ad8bf3331c2dd4a3dcf0193f49c5a123a" title="Assignment operator.">operator=</a>( <a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a> <span class="keyword">const</span>&amp; other )
<a name="l00580"></a>00580    {
<a name="l00581"></a>00581       _name = other._name;
<a name="l00582"></a>00582       _markers = other._markers;
<a name="l00583"></a>00583       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00584"></a>00584    }
<a name="l00585"></a>00585    
<a name="l00587"></a><a class="code" href="classMarkerSet.html#aeb43b9a16f038d8c55fc05a94022c9fb">00587</a>    std::string <span class="keyword">const</span>&amp; <a class="code" href="classMarkerSet.html#aeb43b9a16f038d8c55fc05a94022c9fb" title="The name of the set.">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _name; }
<a name="l00589"></a><a class="code" href="classMarkerSet.html#a2dca3340b43e3f01339d40c74a6f2f88">00589</a>    std::vector&lt;Point3f&gt; <span class="keyword">const</span>&amp; <a class="code" href="classMarkerSet.html#a2dca3340b43e3f01339d40c74a6f2f88" title="Vector of markers making up the set.">markers</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _markers; }
<a name="l00590"></a>00590    
<a name="l00597"></a><a class="code" href="classMarkerSet.html#a6a1a951ee65857f9919a0edcdb5c97bb">00597</a>    <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classMarkerSet.html#a6a1a951ee65857f9919a0edcdb5c97bb" title="Unpack the set from raw packed data.">unpack</a>(<span class="keywordtype">char</span> <span class="keyword">const</span>* data)
<a name="l00598"></a>00598    {
<a name="l00599"></a>00599       <span class="keywordtype">char</span> n[256]; n[255] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00600"></a>00600       <span class="keywordtype">int</span> numMarkers;
<a name="l00601"></a>00601       <span class="keywordtype">int</span> i;
<a name="l00602"></a>00602       <span class="keywordtype">float</span> x,y,z;
<a name="l00603"></a>00603       
<a name="l00604"></a>00604       strncpy(n,data,<span class="keyword">sizeof</span>(n)-1);
<a name="l00605"></a>00605       _name = n;
<a name="l00606"></a>00606       data += strlen(n)+1;
<a name="l00607"></a>00607       
<a name="l00608"></a>00608       memcpy(&amp;numMarkers, data, 4); data += 4;
<a name="l00609"></a>00609       <span class="keywordflow">for</span>( i = 0; i &lt; numMarkers; ++i )
<a name="l00610"></a>00610       {
<a name="l00611"></a>00611          memcpy(&amp;x,data,4); data += 4;
<a name="l00612"></a>00612          memcpy(&amp;y,data,4); data += 4;
<a name="l00613"></a>00613          memcpy(&amp;z,data,4); data += 4;
<a name="l00614"></a>00614          _markers.push_back(<a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>(x,y,z));
<a name="l00615"></a>00615       }
<a name="l00616"></a>00616       
<a name="l00617"></a>00617       <span class="keywordflow">return</span> data;
<a name="l00618"></a>00618    }
<a name="l00619"></a>00619    
<a name="l00620"></a>00620 <span class="keyword">private</span>:
<a name="l00621"></a>00621    
<a name="l00622"></a>00622    std::string _name;
<a name="l00623"></a>00623    std::vector&lt;Point3f&gt; _markers;
<a name="l00624"></a>00624 };
<a name="l00625"></a>00625 
<a name="l00627"></a>00627 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; s, <a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a> <span class="keyword">const</span>&amp; <span class="keyword">set</span> )
<a name="l00628"></a>00628 {
<a name="l00629"></a>00629    <span class="keywordtype">size_t</span> i, size;
<a name="l00630"></a>00630    
<a name="l00631"></a>00631    s
<a name="l00632"></a>00632    &lt;&lt; <span class="stringliteral">&quot;    MarkerSet: &#39;&quot;</span> &lt;&lt; <span class="keyword">set</span>.name() &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
<a name="l00633"></a>00633    
<a name="l00634"></a>00634    std::vector&lt;Point3f&gt; <span class="keyword">const</span>&amp; markers = <span class="keyword">set</span>.markers();
<a name="l00635"></a>00635    size = markers.size();
<a name="l00636"></a>00636    <span class="keywordflow">for</span>( i = 0; i &lt; size; ++i )
<a name="l00637"></a>00637       s &lt;&lt; <span class="stringliteral">&quot;      &quot;</span> &lt;&lt; markers[i];
<a name="l00638"></a>00638    s &lt;&lt; std::endl;
<a name="l00639"></a>00639    
<a name="l00640"></a>00640    <span class="keywordflow">return</span> s;
<a name="l00641"></a>00641 }
<a name="l00642"></a>00642 
<a name="l00649"></a><a class="code" href="classSkeleton.html">00649</a> <span class="keyword">class </span><a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a>
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651 <span class="keyword">public</span>:
<a name="l00652"></a>00652    
<a name="l00653"></a>00653    <a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a>() :
<a name="l00654"></a>00654       _id(0),
<a name="l00655"></a>00655       _rBodies()
<a name="l00656"></a>00656    {
<a name="l00657"></a>00657    }
<a name="l00658"></a>00658    
<a name="l00659"></a>00659    <a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a>( <a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00660"></a>00660       _id(other._id),
<a name="l00661"></a>00661       _rBodies(other._rBodies)
<a name="l00662"></a>00662    {
<a name="l00663"></a>00663    }
<a name="l00664"></a>00664    
<a name="l00665"></a>00665    ~<a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a>(){}
<a name="l00666"></a>00666    
<a name="l00668"></a><a class="code" href="classSkeleton.html#ad4d0cae31c1627a045a9a1d44b1fc895">00668</a>    <span class="keywordtype">int</span> <a class="code" href="classSkeleton.html#ad4d0cae31c1627a045a9a1d44b1fc895" title="ID of this skeleton.">id</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _id; }
<a name="l00670"></a><a class="code" href="classSkeleton.html#a9204c7a748ee645a4c453e1dda2f5b00">00670</a>    std::vector&lt;RigidBody&gt; <span class="keyword">const</span>&amp; <a class="code" href="classSkeleton.html#a9204c7a748ee645a4c453e1dda2f5b00" title="Vector of rigid bodies in this skeleton.">rigidBodies</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _rBodies; }
<a name="l00671"></a>00671    
<a name="l00680"></a><a class="code" href="classSkeleton.html#ae33215cf30ae6ce68588128f6c713e49">00680</a>    <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classSkeleton.html#ae33215cf30ae6ce68588128f6c713e49" title="Unpack skeleton data from raw packed data.">unpack</a>( <span class="keywordtype">char</span> <span class="keyword">const</span>* data, <span class="keywordtype">char</span> nnMajor, <span class="keywordtype">char</span> nnMinor )
<a name="l00681"></a>00681    {
<a name="l00682"></a>00682       <span class="keywordtype">int</span> i;
<a name="l00683"></a>00683       <span class="keywordtype">int</span> numRigid = 0;
<a name="l00684"></a>00684       
<a name="l00685"></a>00685       memcpy(&amp;_id,data,4); data += 4;
<a name="l00686"></a>00686       memcpy(&amp;numRigid,data,4); data += 4;
<a name="l00687"></a>00687       <span class="keywordflow">for</span>( i = 0; i &lt; numRigid; ++i )
<a name="l00688"></a>00688       {
<a name="l00689"></a>00689          <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a> b;
<a name="l00690"></a>00690          data = b.<a class="code" href="classRigidBody.html#ac2670bcfaee0e6224a3a21c32668f415" title="Unpack rigid body data from raw packed data.">unpack</a>( data, nnMajor, nnMinor );
<a name="l00691"></a>00691          _rBodies.push_back(b);
<a name="l00692"></a>00692       }
<a name="l00693"></a>00693       
<a name="l00694"></a>00694       <span class="keywordflow">return</span> data;
<a name="l00695"></a>00695    }
<a name="l00696"></a>00696    
<a name="l00697"></a>00697 <span class="keyword">private</span>:
<a name="l00698"></a>00698    <span class="keywordtype">int</span> _id;
<a name="l00699"></a>00699    std::vector&lt;RigidBody&gt; _rBodies;
<a name="l00700"></a>00700 };
<a name="l00701"></a>00701 
<a name="l00706"></a><a class="code" href="classLabeledMarker.html">00706</a> <span class="keyword">class </span><a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a>
<a name="l00707"></a>00707 {
<a name="l00708"></a>00708 <span class="keyword">public</span>:
<a name="l00709"></a>00709    
<a name="l00711"></a><a class="code" href="classLabeledMarker.html#ad5b6b60859240da85464c4484cb1e01b">00711</a>    <a class="code" href="classLabeledMarker.html#ad5b6b60859240da85464c4484cb1e01b" title="Default constructor.">LabeledMarker</a>() :
<a name="l00712"></a>00712       _id(0),
<a name="l00713"></a>00713       _p(),
<a name="l00714"></a>00714       _size(0.f)
<a name="l00715"></a>00715    {
<a name="l00716"></a>00716    }
<a name="l00717"></a>00717    
<a name="l00718"></a>00718    ~<a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a>(){}
<a name="l00719"></a>00719    
<a name="l00721"></a><a class="code" href="classLabeledMarker.html#aff0e96d4b4807eb08048a1465cf9b90a">00721</a>    <a class="code" href="classLabeledMarker.html#ad5b6b60859240da85464c4484cb1e01b" title="Default constructor.">LabeledMarker</a>( <a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00722"></a>00722       _id(other._id),
<a name="l00723"></a>00723       _p(other._p),
<a name="l00724"></a>00724       _size(other._size)
<a name="l00725"></a>00725    {
<a name="l00726"></a>00726    }
<a name="l00727"></a>00727    
<a name="l00729"></a><a class="code" href="classLabeledMarker.html#ac5292b69ae6bd6f2ed2d4fd62c0977ea">00729</a>    <a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a>&amp; <a class="code" href="classLabeledMarker.html#ac5292b69ae6bd6f2ed2d4fd62c0977ea" title="Assignment operator.">operator=</a>( <a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a> <span class="keyword">const</span>&amp; other )
<a name="l00730"></a>00730    {
<a name="l00731"></a>00731       _id = other._id;
<a name="l00732"></a>00732       _p = other._p;
<a name="l00733"></a>00733       _size = other._size;
<a name="l00734"></a>00734       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00735"></a>00735    }
<a name="l00736"></a>00736    
<a name="l00738"></a><a class="code" href="classLabeledMarker.html#a1a91ca530b84e9c23ee0d8b21ab6a455">00738</a>    <span class="keywordtype">int</span> <a class="code" href="classLabeledMarker.html#a1a91ca530b84e9c23ee0d8b21ab6a455" title="ID of this marker.">id</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _id; }
<a name="l00740"></a><a class="code" href="classLabeledMarker.html#a3459ee5c782ae72395e5d302612bb61c">00740</a>    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> <a class="code" href="classLabeledMarker.html#a3459ee5c782ae72395e5d302612bb61c" title="Location of this marker.">location</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _p; }
<a name="l00742"></a><a class="code" href="classLabeledMarker.html#ab10348f05f67319ffe7d0e2f1a7ed024">00742</a>    <span class="keywordtype">float</span> <a class="code" href="classLabeledMarker.html#ab10348f05f67319ffe7d0e2f1a7ed024" title="Size of this marker.">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _size; }
<a name="l00743"></a>00743    
<a name="l00750"></a><a class="code" href="classLabeledMarker.html#a81625eadea772f87cb72ca8adbd0dfe1">00750</a>    <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classLabeledMarker.html#a81625eadea772f87cb72ca8adbd0dfe1" title="Unpack the marker from packed data.">unpack</a>( <span class="keywordtype">char</span> <span class="keyword">const</span>* data )
<a name="l00751"></a>00751    {
<a name="l00752"></a>00752       memcpy(&amp;_id,data,4); data += 4;
<a name="l00753"></a>00753       memcpy(&amp;_p.x,data,4); data += 4;
<a name="l00754"></a>00754       memcpy(&amp;_p.y,data,4); data += 4;
<a name="l00755"></a>00755       memcpy(&amp;_p.z,data,4); data += 4;
<a name="l00756"></a>00756       memcpy(&amp;_size,data,4); data += 4;
<a name="l00757"></a>00757       
<a name="l00758"></a>00758       <span class="keywordflow">return</span> data;
<a name="l00759"></a>00759    }
<a name="l00760"></a>00760    
<a name="l00761"></a>00761 <span class="keyword">private</span>:
<a name="l00762"></a>00762    <span class="keywordtype">int</span> _id;
<a name="l00763"></a>00763    <a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a> _p;
<a name="l00764"></a>00764    <span class="keywordtype">float</span> _size;
<a name="l00765"></a>00765 };
<a name="l00766"></a>00766 
<a name="l00771"></a><a class="code" href="classMocapFrame.html">00771</a> <span class="keyword">class </span><a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a>
<a name="l00772"></a>00772 {
<a name="l00773"></a>00773 <span class="keyword">public</span>:
<a name="l00774"></a>00774    
<a name="l00784"></a><a class="code" href="classMocapFrame.html#ae374819e609e2e32d49a3816e0955f0c">00784</a>    <a class="code" href="classMocapFrame.html#ae374819e609e2e32d49a3816e0955f0c" title="Constructor.">MocapFrame</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> nnMajor=0, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> nnMinor=0 ) :
<a name="l00785"></a>00785       _nnMajor(nnMajor),
<a name="l00786"></a>00786       _nnMinor(nnMinor),
<a name="l00787"></a>00787       _frameNum(0),
<a name="l00788"></a>00788       _numMarkerSets(0),
<a name="l00789"></a>00789       _numRigidBodies(0)
<a name="l00790"></a>00790    {
<a name="l00791"></a>00791       
<a name="l00792"></a>00792    }
<a name="l00793"></a>00793    ~<a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a>(){}
<a name="l00794"></a>00794    
<a name="l00796"></a><a class="code" href="classMocapFrame.html#aaf32d0e6a7ad581690325c5886f0c96f">00796</a>    <a class="code" href="classMocapFrame.html#ae374819e609e2e32d49a3816e0955f0c" title="Constructor.">MocapFrame</a>( <a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a> <span class="keyword">const</span>&amp; other ) :
<a name="l00797"></a>00797       _nnMajor(other._nnMajor),
<a name="l00798"></a>00798       _nnMinor(other._nnMinor),
<a name="l00799"></a>00799       _frameNum(other._frameNum),
<a name="l00800"></a>00800       _numMarkerSets(other._numMarkerSets),
<a name="l00801"></a>00801       _markerSet(other._markerSet),
<a name="l00802"></a>00802       _uidMarker(other._uidMarker),
<a name="l00803"></a>00803       _numRigidBodies(other._numRigidBodies),
<a name="l00804"></a>00804       _rBodies(other._rBodies),
<a name="l00805"></a>00805       _skel(other._skel),
<a name="l00806"></a>00806       _labeledMarkers(other._labeledMarkers),
<a name="l00807"></a>00807       _latency(other._latency),
<a name="l00808"></a>00808       _timecode(other._timecode),
<a name="l00809"></a>00809       _subTimecode(other._subTimecode)
<a name="l00810"></a>00810    {
<a name="l00811"></a>00811       
<a name="l00812"></a>00812    }
<a name="l00813"></a>00813    
<a name="l00815"></a><a class="code" href="classMocapFrame.html#a9649550bd0d15aa01e377857c098319f">00815</a>    <a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a>&amp; <a class="code" href="classMocapFrame.html#a9649550bd0d15aa01e377857c098319f" title="Assignment operator.">operator=</a>( <a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a> <span class="keyword">const</span>&amp; other )
<a name="l00816"></a>00816    {
<a name="l00817"></a>00817       _nnMajor = other._nnMajor;
<a name="l00818"></a>00818       _nnMinor = other._nnMinor;
<a name="l00819"></a>00819       _frameNum = other._frameNum;
<a name="l00820"></a>00820       _numMarkerSets = other._numMarkerSets;
<a name="l00821"></a>00821       _markerSet = other._markerSet;
<a name="l00822"></a>00822       _uidMarker = other._uidMarker;
<a name="l00823"></a>00823       _numRigidBodies = other._numRigidBodies;
<a name="l00824"></a>00824       _rBodies = other._rBodies;
<a name="l00825"></a>00825       _skel = other._skel;
<a name="l00826"></a>00826       _labeledMarkers = other._labeledMarkers;
<a name="l00827"></a>00827       _latency = other._latency;
<a name="l00828"></a>00828       _timecode = other._timecode;
<a name="l00829"></a>00829       _subTimecode = other._subTimecode;
<a name="l00830"></a>00830       
<a name="l00831"></a>00831       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00832"></a>00832    }
<a name="l00833"></a>00833    
<a name="l00840"></a><a class="code" href="classMocapFrame.html#a646c39de6dc91cd3f1acb8b90cfc90c1">00840</a>    <span class="keywordtype">int</span> <a class="code" href="classMocapFrame.html#a646c39de6dc91cd3f1acb8b90cfc90c1" title="Frame number.">frameNum</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _frameNum; }
<a name="l00842"></a><a class="code" href="classMocapFrame.html#a0cf3cb2de725cb46186cedb13ff0a71c">00842</a>    std::vector&lt;MarkerSet&gt; <span class="keyword">const</span>&amp; <a class="code" href="classMocapFrame.html#a0cf3cb2de725cb46186cedb13ff0a71c" title="All the sets of markers except unidentified ones.">markerSets</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _markerSet; }
<a name="l00844"></a><a class="code" href="classMocapFrame.html#a70c364d5725dd792b2ab1e7ab66104cb">00844</a>    std::vector&lt;Point3f&gt; <span class="keyword">const</span>&amp; <a class="code" href="classMocapFrame.html#a70c364d5725dd792b2ab1e7ab66104cb" title="Set of unidentified markers.">unIdMarkers</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _uidMarker; }
<a name="l00846"></a><a class="code" href="classMocapFrame.html#a07a3a094cd6cc30e7b0ad0a52bf8a03f">00846</a>    std::vector&lt;RigidBody&gt; <span class="keyword">const</span>&amp; <a class="code" href="classMocapFrame.html#a07a3a094cd6cc30e7b0ad0a52bf8a03f" title="All the rigid bodies.">rigidBodies</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _rBodies; }
<a name="l00854"></a><a class="code" href="classMocapFrame.html#aa5a43b1f1ac04329e15784f8131d7328">00854</a>    <span class="keywordtype">float</span> <a class="code" href="classMocapFrame.html#aa5a43b1f1ac04329e15784f8131d7328" title="Either latency or timecode for the current frame.">latency</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _latency; }
<a name="l00861"></a><a class="code" href="classMocapFrame.html#a2cc6b360c320b0119403fb79f1cd1ef2">00861</a>    <span class="keywordtype">void</span> <a class="code" href="classMocapFrame.html#a2cc6b360c320b0119403fb79f1cd1ef2" title="SMTPE timecode and sub-timecode.">timecode</a>( uint32_t&amp; <a class="code" href="classMocapFrame.html#a2cc6b360c320b0119403fb79f1cd1ef2" title="SMTPE timecode and sub-timecode.">timecode</a>, uint32_t&amp; subframe )<span class="keyword"> const</span>
<a name="l00862"></a>00862 <span class="keyword">   </span>{
<a name="l00863"></a>00863       timecode = _timecode;
<a name="l00864"></a>00864       subframe = _subTimecode;
<a name="l00865"></a>00865    }
<a name="l00875"></a><a class="code" href="classMocapFrame.html#ad56edd4018b93a966f8e817c80e69894">00875</a>    <span class="keywordtype">void</span> <a class="code" href="classMocapFrame.html#a2cc6b360c320b0119403fb79f1cd1ef2" title="SMTPE timecode and sub-timecode.">timecode</a>(
<a name="l00876"></a>00876       <span class="keywordtype">int</span>&amp; hour,
<a name="l00877"></a>00877       <span class="keywordtype">int</span>&amp; minute,
<a name="l00878"></a>00878       <span class="keywordtype">int</span>&amp; second,
<a name="l00879"></a>00879       <span class="keywordtype">int</span>&amp; frame,
<a name="l00880"></a>00880       <span class="keywordtype">int</span>&amp; subFrame
<a name="l00881"></a>00881    )<span class="keyword"> const</span>
<a name="l00882"></a>00882 <span class="keyword">   </span>{
<a name="l00883"></a>00883       hour = (_timecode&gt;&gt;24)&amp;0xFF;
<a name="l00884"></a>00884       minute = (_timecode&gt;&gt;16)&amp;0xFF;
<a name="l00885"></a>00885       second = (_timecode&gt;&gt;8)&amp;0xFF;
<a name="l00886"></a>00886       frame = _timecode&amp;0xFF;
<a name="l00887"></a>00887       subFrame = _subTimecode;
<a name="l00888"></a>00888    }
<a name="l00889"></a>00889    
<a name="l00900"></a><a class="code" href="classMocapFrame.html#a4c1ef6be087c822ce82991349c13e20a">00900</a>    <span class="keywordtype">char</span> <span class="keyword">const</span>* <a class="code" href="classMocapFrame.html#a4c1ef6be087c822ce82991349c13e20a" title="Unpack frame data from a packed buffer.">unpack</a>(<span class="keywordtype">char</span> <span class="keyword">const</span>* data)
<a name="l00901"></a>00901    {
<a name="l00902"></a>00902       <span class="keywordtype">int</span> i;
<a name="l00903"></a>00903       <span class="keywordtype">int</span> numUidMarkers;
<a name="l00904"></a>00904       <span class="keywordtype">float</span> x,y,z;
<a name="l00905"></a>00905       
<a name="l00906"></a>00906       <span class="comment">//char const* const dataBeg = data;</span>
<a name="l00907"></a>00907       
<a name="l00908"></a>00908       <span class="comment">// NOTE: need to worry about network order here?</span>
<a name="l00909"></a>00909       
<a name="l00910"></a>00910       <span class="comment">// Get frame number.</span>
<a name="l00911"></a>00911       memcpy(&amp;_frameNum, data, 4); data += 4;
<a name="l00912"></a>00912       
<a name="l00913"></a>00913       <span class="comment">// Get marker sets.</span>
<a name="l00914"></a>00914       memcpy(&amp;_numMarkerSets, data, 4); data += 4;
<a name="l00915"></a>00915       <span class="keywordflow">for</span>( i = 0; i &lt; _numMarkerSets; ++i )
<a name="l00916"></a>00916       {
<a name="l00917"></a>00917          <a class="code" href="classMarkerSet.html" title="A set of markers.">MarkerSet</a> <span class="keyword">set</span>;
<a name="l00918"></a>00918          data = <span class="keyword">set</span>.<a class="code" href="classMarkerSet.html#a6a1a951ee65857f9919a0edcdb5c97bb" title="Unpack the set from raw packed data.">unpack</a>(data);
<a name="l00919"></a>00919          _markerSet.push_back(<span class="keyword">set</span>);
<a name="l00920"></a>00920       }
<a name="l00921"></a>00921       
<a name="l00922"></a>00922       <span class="comment">// Get unidentified markers.</span>
<a name="l00923"></a>00923       memcpy(&amp;numUidMarkers,data,4); data += 4;
<a name="l00924"></a>00924       <span class="keywordflow">for</span>( i = 0; i &lt; numUidMarkers; ++i )
<a name="l00925"></a>00925       {
<a name="l00926"></a>00926          memcpy(&amp;x,data,4); data += 4;
<a name="l00927"></a>00927          memcpy(&amp;y,data,4); data += 4;
<a name="l00928"></a>00928          memcpy(&amp;z,data,4); data += 4;
<a name="l00929"></a>00929          _uidMarker.push_back(<a class="code" href="classPoint3f.html" title="Simple 3D point.">Point3f</a>(x,y,z));
<a name="l00930"></a>00930       }
<a name="l00931"></a>00931       
<a name="l00932"></a>00932       <span class="comment">// Get rigid bodies</span>
<a name="l00933"></a>00933       _numRigidBodies = 0;
<a name="l00934"></a>00934       memcpy(&amp;_numRigidBodies,data,4); data += 4;
<a name="l00935"></a>00935       <span class="keywordflow">for</span>( i = 0; i &lt; _numRigidBodies; ++i )
<a name="l00936"></a>00936       {
<a name="l00937"></a>00937          <a class="code" href="classRigidBody.html" title="Rigid body.">RigidBody</a> b;
<a name="l00938"></a>00938          data = b.<a class="code" href="classRigidBody.html#ac2670bcfaee0e6224a3a21c32668f415" title="Unpack rigid body data from raw packed data.">unpack</a>(data, _nnMajor, _nnMinor);
<a name="l00939"></a>00939          _rBodies.push_back(b);
<a name="l00940"></a>00940       }
<a name="l00941"></a>00941       
<a name="l00942"></a>00942       <span class="comment">// Get skeletons (NatNet 2.1 and later)</span>
<a name="l00943"></a>00943       <span class="keywordflow">if</span>( _nnMajor &gt; 2 || (_nnMajor==2 &amp;&amp; _nnMinor &gt;= 1) )
<a name="l00944"></a>00944       {
<a name="l00945"></a>00945          <span class="keywordtype">int</span> numSkel = 0;
<a name="l00946"></a>00946          memcpy(&amp;numSkel,data,4); data += 4;
<a name="l00947"></a>00947          <span class="keywordflow">for</span>( i = 0; i &lt; numSkel; ++i )
<a name="l00948"></a>00948          {
<a name="l00949"></a>00949             <a class="code" href="classSkeleton.html" title="A composition of rigid bodies.">Skeleton</a> s;
<a name="l00950"></a>00950             data = s.<a class="code" href="classSkeleton.html#ae33215cf30ae6ce68588128f6c713e49" title="Unpack skeleton data from raw packed data.">unpack</a>( data, _nnMajor, _nnMinor );
<a name="l00951"></a>00951             _skel.push_back(s);
<a name="l00952"></a>00952          }
<a name="l00953"></a>00953       }
<a name="l00954"></a>00954       
<a name="l00955"></a>00955       <span class="comment">// Get labeled markers (NatNet 2.3 and later)</span>
<a name="l00956"></a>00956       <span class="keywordflow">if</span>( _nnMajor &gt; 2 || (_nnMajor==2 &amp;&amp; _nnMinor &gt;= 3) )
<a name="l00957"></a>00957       {
<a name="l00958"></a>00958          <span class="keywordtype">int</span> numLabMark = 0;
<a name="l00959"></a>00959          memcpy(&amp;numLabMark,data,4); data += 4;
<a name="l00960"></a>00960          <span class="keywordflow">for</span>( i = 0; i &lt; numLabMark; ++i )
<a name="l00961"></a>00961          {
<a name="l00962"></a>00962             <a class="code" href="classLabeledMarker.html" title="A labeled marker.">LabeledMarker</a> lm;
<a name="l00963"></a>00963             data = lm.<a class="code" href="classLabeledMarker.html#a81625eadea772f87cb72ca8adbd0dfe1" title="Unpack the marker from packed data.">unpack</a>(data);
<a name="l00964"></a>00964             _labeledMarkers.push_back(lm);
<a name="l00965"></a>00965          }
<a name="l00966"></a>00966       }
<a name="l00967"></a>00967       
<a name="l00968"></a>00968       <span class="comment">// Get latency/timecode</span>
<a name="l00969"></a>00969       memcpy(&amp;_latency,data,4); data += 4;
<a name="l00970"></a>00970       
<a name="l00971"></a>00971       <span class="comment">// Get timecode</span>
<a name="l00972"></a>00972       memcpy(&amp;_timecode,data,4); data += 4;
<a name="l00973"></a>00973       memcpy(&amp;_subTimecode,data,4); data += 4;
<a name="l00974"></a>00974       
<a name="l00975"></a>00975       <span class="comment">// Get &quot;end of data&quot; tag</span>
<a name="l00976"></a>00976       <span class="keywordtype">int</span> eod = 0;
<a name="l00977"></a>00977       memcpy(&amp;eod,data,4); data += 4;
<a name="l00978"></a>00978       
<a name="l00979"></a>00979       <span class="keywordflow">return</span> data;
<a name="l00980"></a>00980    }
<a name="l00981"></a>00981    
<a name="l00982"></a>00982 <span class="keyword">private</span>:
<a name="l00983"></a>00983    
<a name="l00984"></a>00984    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _nnMajor;
<a name="l00985"></a>00985    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _nnMinor;
<a name="l00986"></a>00986    
<a name="l00987"></a>00987    <span class="keywordtype">int</span> _frameNum;
<a name="l00988"></a>00988    <span class="keywordtype">int</span> _numMarkerSets;
<a name="l00989"></a>00989    <span class="comment">// A list of marker sets. May subsume _numMarkerSets.</span>
<a name="l00990"></a>00990    std::vector&lt;MarkerSet&gt; _markerSet;
<a name="l00991"></a>00991    <span class="comment">// Set of unidentified markers.</span>
<a name="l00992"></a>00992    std::vector&lt;Point3f&gt; _uidMarker;
<a name="l00993"></a>00993    <span class="keywordtype">int</span> _numRigidBodies;
<a name="l00994"></a>00994    <span class="comment">// A list of rigid bodies.</span>
<a name="l00995"></a>00995    std::vector&lt;RigidBody&gt; _rBodies;
<a name="l00996"></a>00996    <span class="comment">// A list of skeletons.</span>
<a name="l00997"></a>00997    std::vector&lt;Skeleton&gt; _skel;
<a name="l00998"></a>00998    <span class="comment">// A list of labeled markers.</span>
<a name="l00999"></a>00999    std::vector&lt;LabeledMarker&gt; _labeledMarkers;
<a name="l01000"></a>01000    <span class="comment">// Latency</span>
<a name="l01001"></a>01001    <span class="keywordtype">float</span> _latency;
<a name="l01002"></a>01002    <span class="comment">// Timestamp;</span>
<a name="l01003"></a>01003    uint32_t _timecode;
<a name="l01004"></a>01004    uint32_t _subTimecode;
<a name="l01005"></a>01005 };
<a name="l01006"></a>01006 
<a name="l01008"></a>01008 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, <a class="code" href="classMocapFrame.html" title="A complete frame of motion capture data.">MocapFrame</a> <span class="keyword">const</span>&amp; frame)
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010    <span class="keywordtype">size_t</span> i, size;
<a name="l01011"></a>01011    std::ios::fmtflags flags = s.flags();
<a name="l01012"></a>01012    
<a name="l01013"></a>01013    s
<a name="l01014"></a>01014    &lt;&lt; <span class="stringliteral">&quot;--Frame--&quot;</span> &lt;&lt; std::endl
<a name="l01015"></a>01015    &lt;&lt; <span class="stringliteral">&quot;  Frame #: &quot;</span> &lt;&lt; frame.<a class="code" href="classMocapFrame.html#a646c39de6dc91cd3f1acb8b90cfc90c1" title="Frame number.">frameNum</a>() &lt;&lt; std::endl;
<a name="l01016"></a>01016    
<a name="l01017"></a>01017    std::vector&lt;MarkerSet&gt; <span class="keyword">const</span>&amp; markerSets = frame.<a class="code" href="classMocapFrame.html#a0cf3cb2de725cb46186cedb13ff0a71c" title="All the sets of markers except unidentified ones.">markerSets</a>();
<a name="l01018"></a>01018    size = markerSets.size();
<a name="l01019"></a>01019    
<a name="l01020"></a>01020    s
<a name="l01021"></a>01021    &lt;&lt; <span class="stringliteral">&quot;  Marker Sets: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;
<a name="l01022"></a>01022    <span class="keywordflow">for</span>( i = 0; i &lt; size; ++i )
<a name="l01023"></a>01023       s &lt;&lt; markerSets[i];
<a name="l01024"></a>01024    
<a name="l01025"></a>01025    s
<a name="l01026"></a>01026    &lt;&lt; <span class="stringliteral">&quot;  Unidentified Markers: &quot;</span> &lt;&lt; frame.<a class="code" href="classMocapFrame.html#a70c364d5725dd792b2ab1e7ab66104cb" title="Set of unidentified markers.">unIdMarkers</a>().size() &lt;&lt; std::endl;
<a name="l01027"></a>01027    
<a name="l01028"></a>01028    std::vector&lt;RigidBody&gt; <span class="keyword">const</span>&amp; rBodies = frame.<a class="code" href="classMocapFrame.html#a07a3a094cd6cc30e7b0ad0a52bf8a03f" title="All the rigid bodies.">rigidBodies</a>();
<a name="l01029"></a>01029    size = rBodies.size();
<a name="l01030"></a>01030    s
<a name="l01031"></a>01031    &lt;&lt; <span class="stringliteral">&quot;  Rigid Bodies: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;
<a name="l01032"></a>01032    <span class="keywordflow">for</span>( i = 0; i &lt; size; ++i )
<a name="l01033"></a>01033       s &lt;&lt; rBodies[i];
<a name="l01034"></a>01034 
<a name="l01035"></a>01035    <span class="keywordtype">int</span> hour,min,sec,fframe,subframe;
<a name="l01036"></a>01036    frame.<a class="code" href="classMocapFrame.html#a2cc6b360c320b0119403fb79f1cd1ef2" title="SMTPE timecode and sub-timecode.">timecode</a>(hour,min,sec,fframe,subframe);
<a name="l01037"></a>01037    
<a name="l01038"></a>01038    s.setf( s.fixed, s.floatfield );
<a name="l01039"></a>01039    s.precision(4);
<a name="l01040"></a>01040    s
<a name="l01041"></a>01041    &lt;&lt; <span class="stringliteral">&quot;  Latency: &quot;</span> &lt;&lt; frame.<a class="code" href="classMocapFrame.html#aa5a43b1f1ac04329e15784f8131d7328" title="Either latency or timecode for the current frame.">latency</a>() &lt;&lt; std::endl
<a name="l01042"></a>01042    &lt;&lt; <span class="stringliteral">&quot;  Timecode: &quot;</span> &lt;&lt; hour &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; min &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; fframe &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; subframe &lt;&lt; std::endl;
<a name="l01043"></a>01043    
<a name="l01044"></a>01044    s &lt;&lt; <span class="stringliteral">&quot;++Frame++&quot;</span> &lt;&lt; std::endl;
<a name="l01045"></a>01045    
<a name="l01046"></a>01046    s.flags(flags);
<a name="l01047"></a>01047    <span class="keywordflow">return</span> s;
<a name="l01048"></a>01048 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="preprocessor">#endif </span><span class="comment">/*NATNET_H*/</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 21:06:56 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
